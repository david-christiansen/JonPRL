Operator fst : (0).
Operator snd : (0).

[fst(p)] =def= [spread(p; x.y.x)].
[snd(p)] =def= [spread(p; x.y.y)].

||| Ambient category

Operator CTT : (0;0).

[CTT(A;B)] =def= [Π(A; _. B)].

||| Power

Operator Power : (0;0).

[Power(A;B)] =def= [Π(A; _. B)].

||| Copower

Operator Copower : (0;0).

[Copower(A;B)] =def= [Σ(A; _. B)].

||| End

Operator End : (0).

[End(Hom)] =def= [Π(U<0>; A. ap(ap(Hom; A); A))].

Theorem End_wf : [
  ∀(Π(U<0>; _. Π(U<0>; _. U<0>)); Hom. ∈(End(Hom); U<1>))
] {
  unfold <End>; auto.
}.

||| Coend

Operator Coend : (0).

[Coend(Hom)] =def= [Σ(U<0>; A. ap(ap(Hom; A); A))].

Theorem Coend_wf : [
  ∀(Π(U<0>; _. Π(U<0>; _. U<0>)); Hom. ∈(Coend(Hom); U<1>))
] {
  unfold <Coend>; auto.
}.

||| Ran

Operator Ran : (0;0;0).

[Ran(G;H;A)] =def= [End(λ(X. λ(Y. Power(CTT(A; ap(G;X)); ap(H;Y)))))].

Theorem Ran_wf : [
  ∀(Π(U<0>; _. U<0>); G.
  ∀(Π(U<0>; _. U<0>); H.
  ∀(U<0>; A.
    ∈(Ran(G;H;A); U<1>))))
] {
  unfold <Ran Power End CTT>; auto.
}.

||| Lan

Operator Lan : (0;0;0).

[Lan(G;H;A)] =def= [Coend(λ(X. λ(Y. Copower(CTT(ap(G;X); A); ap(H;Y)))))].

Theorem Lan_wf : [
  ∀(Π(U<0>; _. U<0>); G.
  ∀(Π(U<0>; _. U<0>); H.
  ∀(U<0>; A.
    ∈(Lan(G;H;A); U<1>))))
] {
  unfold <Lan Copower Coend CTT>; auto.
}.

||| Bundles / Fibrations

Operator Bundle : (0).
Operator dom : (0).
Operator map : (0;0).

[Bundle(B)] =def= [Σ(U<0>; Dom. Π(Dom; _. B))].
[dom(f)] =def= [fst(f)].
[map(f;b)] =def= [ap(snd(f); b)].

Theorem Bundle_wf : [∀(U<0>; B. ∈(Bundle(B); U<1>))] {
  unfold <Bundle>; auto
}.
Theorem dom_wf : [∀(U<0>; B. ∀(Bundle(B); f. ∈(dom(f); U<0>)))] {
  unfold <Bundle map dom fst>; auto
}.
Theorem map_wf : [
  ∀(U<0>; B. ∀(Bundle(B); f. ∀(dom(f); x. ∈(map(f;x); B))))
] {
  unfold <Bundle dom map fst snd>; auto.
}.

||| Fibers of a bundle over a point

Operator Fiber : (0;0;0).

[Fiber(B; f; b)] =def= [Σ(dom(f); x. =(b; map(f;x); B))].

Theorem Fiber_wf : [
  ∀(U<0>; B. ∀(Bundle(B); f. ∀(B; b. ∈(Fiber(B;f;b); U<0>))))
] {
  unfold <Bundle Fiber dom map fst snd>; auto.
}.

||| Polynomials (non-indexed)

Operator Polynomial : ().
Operator base : (0).
Operator bundle : (0).

[Polynomial] =def= [Σ(U<0>; Base. Bundle(Base))].
[base(E)] =def= [fst(E)].
[bundle(E)] =def= [snd(E)].

Theorem Polynomial_wf : [∈(Polynomial; U<1>)] {
  unfold <Polynomial Bundle>; auto
}.

||| Yoneda embedding

Operator Embed : (0).

[Embed(B)] =def= [λ(A. Π(A; _. B))].

Theorem Embed_wf : [
  ∀(U<0>; B. ∀(U<0>; X. ∈(ap(Embed(B); X); U<0>)))
] {
  unfold <Embed>; auto.
}.

||| Extension functors of polynomials

Operator Ext : (0;0).

[Ext(p;X)] =def= [Σ(base(p); b. ap(Embed(X); Fiber(base(p); bundle(p); b)))].

Theorem Ext_wf : [
  ∀(Polynomial; p. ∀(U<0>; X. ∈(Ext(p;X); U<1>)))
] {
  unfold <Polynomial Ext Bundle base Embed Fiber bundle dom map fst snd>; auto;
  unfold <snd>; auto
}.

||| Bundle pullbacks

Operator Pullback : (0;0;0).

[Pullback(B;f;g)] =def= [Σ(dom(f); x. Fiber(B; g; map(f;x)))].

Theorem Pullback_wf : [
  ∀(U<0>; B. ∀(Bundle(B); f. ∀(Bundle(B); g.
    ∈(Pullback(B;f;g); U<0>))))
] {
  unfold <Pullback Bundle Fiber map dom fst snd>; auto.
}.
